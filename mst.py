import hashlib
import dag_cbor
import operator
from multiformats import multihash, CID
from functools import cached_property
from more_itertools import ilen
from itertools import takewhile
from dataclasses import dataclass
from typing import Tuple, Self, Optional, Any, Type, Iterable

from util import indent, hash_to_cid
from blockstore import BlockStore, MemoryBlockStore

# tuple helpers
def tuple_replace_at(original: tuple, i: int, value: Any) -> tuple:
	return original[:i] + (value,) + original[i + 1:]

def tuple_insert_at(original: tuple, i: int, value: Any) -> tuple:
	return original[:i] + (value,) + original[i:]

def tuple_remove_at(original: tuple, i: int) -> tuple:
	return original[:i] + original[i + 1:]


@dataclass(frozen=True) # frozen == immutable == win
class MSTNode:
	"""
	k/v pairs are interleaved between subtrees like so:

	keys:          (0,    1,    2,    3)
	vals:          (0,    1,    2,    3)
	subtrees:   (0,    1,    2,    3,    4)
	"""
	keys: Tuple[str] # collection/rkey
	vals: Tuple[CID] # record CIDs
	subtrees: Tuple[Optional[CID]] # a None value represents an empty subtree


	# NB: __init__ is auto-generated by dataclass decorator

	# these checks should never fail, and could be skipped for performance
	def __post_init__(self) -> None:
		# TODO: maybe check that they're tuples here?
		# implicitly, the length of self.subtrees must be at least 1
		if len(self.subtrees) != len(self.keys) + 1:
			raise ValueError("Invalid subtree count")
		if len(self.keys) != len(self.vals):
			raise ValueError("Mismatched keys/vals lengths")

	@classmethod
	def empty_root(cls) -> Self:
		return cls(
			subtrees=(None,),
			keys=(),
			vals=()
		)

	@staticmethod
	def key_height(key: str) -> int:
		digest = int.from_bytes(hashlib.sha256(key.encode()).digest(), "big")
		leading_zeroes = 256 - digest.bit_length()
		return leading_zeroes // 2

	# since we're immutable, this can be cached
	@cached_property
	def cid(self) -> CID:
		digest = multihash.digest(self.serialised, "sha2-256")
		cid = CID("base32", 1, "dag-cbor", digest)
		return cid

	# likewise
	@cached_property
	def serialised(self) -> bytes:
		e = []
		prev_key = b""
		for subtree, key_str, value in zip(self.subtrees[1:], self.keys, self.vals):
			key_bytes = key_str.encode()
			shared_prefix_len = ilen(takewhile(bool, map(operator.eq, prev_key, key_bytes))) # I love functional programming
			e.append({
				"k": key_bytes[shared_prefix_len:],
				"p": shared_prefix_len,
				"t": subtree,
				"v": value,
			})
			prev_key = key_bytes
		return dag_cbor.encode({
			"e": e,
			"l": self.subtrees[0]
		})

	@classmethod
	def deserialise(cls, data: bytes) -> Self:
		cbor = dag_cbor.decode(data)
		if len(cbor) != 2: # e, l
			raise ValueError("malformed MST node")
		subtrees = [cbor["l"]]
		keys = []
		vals = []
		prev_key = b""
		for e in cbor["e"]: # TODO: make extra sure that these checks are watertight
			if len(e) != 4: # k, p, t, v
				raise ValueError("malformed MST node")
			prefix_len: int = e["p"]
			suffix: bytes = e["k"]
			if prefix_len > len(prev_key):
				raise ValueError("invalid MST key prefix len")
			if prev_key[prefix_len:prefix_len+1] == suffix[:1]:
				raise ValueError("non-optimal MST key prefix len")
			this_key = prev_key[:prefix_len] + suffix
			if this_key <= prev_key:
				raise ValueError("invalid MST key sort order")
			keys.append(this_key.decode())
			vals.append(e["v"])
			subtrees.append(e["t"])
			prev_key = this_key

		return cls(
			subtrees=tuple(subtrees),
			keys=tuple(keys),
			vals=tuple(vals)
		)
	
	def is_empty(self) -> bool:
		return self.subtrees == (None,)

	def _to_optional(self) -> Optional[CID]:
		"""
		returns None if the node is empty
		"""
		if self.is_empty():
			return None
		return self.cid


	@cached_property
	def height(self) -> int:
		# if there are keys at this level, query one directly
		if self.keys:
			return self.key_height(self.keys[0])
		
		# we're an empty tree
		if self.subtrees[0] is None:
			return 0
		
		# this should only happen for non-root nodes with no keys
		raise Exception("cannot determine node height")
	
	def gte_index(self, key: str) -> int:
		"""
		find the index of the first key greater than or equal to the specified key
		if all keys are smaller, it returns len(keys)
		"""
		i = 0 # this loop could be a binary search but not worth it for small fanouts
		while i < len(self.keys) and key > self.keys[i]:
			i += 1
		return i


class NodeStore:
	"""
	NodeStore wraps a BlockStore to provide a more ergonomic interface
	for loading and storing MSTNodes
	"""
	bs: BlockStore

	def __init__(self, bs: BlockStore) -> None:
		self.bs = bs
	
	# TODO: LRU cache this
	def get(self, cid: Optional[CID]) -> MSTNode:
		"""
		if cid is None, returns an empty MST node
		"""
		if cid is None:
			return self.put(MSTNode.empty_root())
		
		return MSTNode.deserialise(self.bs.get(bytes(cid)))
	
	# TODO: also put in cache
	def put(self, node: MSTNode) -> MSTNode:
		self.bs.put(bytes(node.cid), node.serialised)
		return node # this is convenient


class NodeWrangler:
	"""
	NodeWrangler is where core MST transformation ops are implemented, backed
	by a NodeStore
	"""
	ns: NodeStore

	def __init__(self, ns: NodeStore) -> None:
		self.ns = ns

	def put(self, root_cid: CID, key: str, val: CID) -> CID:
		root = ns.get(root_cid)
		if root.is_empty(): # special case for empty tree
			return self._put_here(root, key, val)
		return self._put_recursive(root, key, val, MSTNode.key_height(key), root.height)

	def delete(self, root_cid: CID, key: str) -> CID:
		root = ns.get(root_cid)

		# Note: the seemingly redundant outer .get().cid is required to transform
		# a None cid into the cid representing an empty node (we could maybe find a more elegant
		# way of doing this...)
		return self.ns.get(self._squash_top(self._delete_recursive(root, key, MSTNode.key_height(key), root.height))).cid



	def _put_here(self, node: MSTNode, key: str, val: CID) -> CID:
		i = node.gte_index(key)

		# the key is already present!
		if i < len(node.keys) and node.keys[i] == key:
			if node.vals[i] == val:
				return node.cid # we can return our old self if there is no change
			return self.ns.put(MSTNode(
				keys=node.keys,
				vals=tuple_replace_at(node.vals, i, val),
				subtrees=node.subtrees
			)).cid
		
		return self.ns.put(MSTNode(
			keys=tuple_insert_at(node.keys, i, key),
			vals=tuple_insert_at(node.vals, i, val),
			subtrees = node.subtrees[:i] + \
				self._split_on_key(node.subtrees[i], key) + \
				node.subtrees[i + 1:],
		)).cid
	
	def _put_recursive(self, node: MSTNode, key: str, val: CID, key_height: int, tree_height: int) -> CID:
		if key_height > tree_height: # we need to grow the tree
			return self.ns.put(self._put_recursive(
				MSTNode.empty_root(),
				key, val, key_height, tree_height + 1
			)).cid
		
		if key_height < tree_height: # we need to look below
			i = node.gte_index(key)
			return self.ns.put(MSTNode(
				keys=node.keys,
				vals=node.vals,
				subtrees=tuple_replace_at(
					node.subtrees, i,
					self._put_recursive(
						self.ns.get(node.subtrees[i]),
						key, val, key_height, tree_height - 1
					)
				)
			)).cid
		
		# we can insert here
		assert(key_height == tree_height)
		return self._put_here(node, key, val)
	
	def _split_on_key(self, node_cid: Optional[CID], key: str) -> Tuple[Optional[CID], Optional[CID]]:
		if node_cid is None:
			return None, None
		node = ns.get(node_cid)
		i = node.gte_index(key)
		lsub, rsub = self._split_on_key(node.subtrees[i], key)
		return self.ns.put(MSTNode(
			keys=node.keys[:i],
			vals=node.vals[:i],
			subtrees=node.subtrees[:i] + (lsub,)
		))._to_optional(), self.ns.put(MSTNode(
			keys=node.keys[i:],
			vals=node.vals[i:],
			subtrees=(rsub,) + node.subtrees[i + 1:],
		))._to_optional()

	def _squash_top(self, node_cid: Optional[CID]) -> Optional[CID]:
		"""
		strip empty nodes from the top of the tree
		"""
		node = self.ns.get(node_cid)
		if node.keys:
			return node_cid
		if node.subtrees[0] is None:
			return node_cid
		return self._squash_top(node.subtrees[0])

	def _delete_recursive(self, node: MSTNode, key: str, key_height: int, tree_height: int) -> Optional[CID]:
		if key_height > tree_height: # the key cannot possibly be in this tree, no change needed
			return node._to_optional()
		
		i = node.gte_index(key)
		if key_height < tree_height: # the key must be deleted from a subtree
			if node.subtrees[i] is None:
				return node._to_optional() # the key cannot be in this subtree, no change needed
			return self.ns.put(MSTNode(
				keys=node.keys,
				vals=node.vals,
				subtrees=tuple_replace_at(
					node.subtrees,
					i,
					self._delete_recursive(self.ns.get(node.subtrees[i]), key, key_height, tree_height - 1)
				)
			))._to_optional()
		
		i = node.gte_index(key)
		if i == len(node.keys) or node.keys[i] != key:
			return node._to_optional() # key already not present
		
		assert(node.keys[i] == key) # sanity check (should always be true)

		return self.ns.put(MSTNode(
			keys=tuple_remove_at(node.keys, i),
			vals=tuple_remove_at(node.vals, i),
			subtrees=node.subtrees[:i] + (
				self._merge(node.subtrees[i], node.subtrees[i + 1]),
			) + node.subtrees[i + 2:]
		))._to_optional()
	
	def _merge(self, left_cid: Optional[CID], right_cid: Optional[CID]) -> Optional[CID]:
		if left_cid is None:
			return right_cid # includes the case where left == right == None
		if right_cid is None:
			return left_cid
		left = self.ns.get(left_cid)
		right = self.ns.get(right_cid)
		return self.ns.put(MSTNode(
			keys=left.keys + right.keys,
			vals=left.vals + right.vals,
			subtrees=left.subtrees[:-1] + (
				self._merge(
					left.subtrees[-1],
					right.subtrees[0]
				),
			 ) + right.subtrees[1:]
		))._to_optional()
	
	def pretty(self, node_cid: Optional[CID]) -> str:
		if node_cid is None:
			return "<empty>"
		node = self.ns.get(node_cid)
		res = f"MSTNode<cid={node.cid.encode("base32")}>(\n{indent(self.pretty(node.subtrees[0]))},\n"
		for k, v, t in zip(node.keys, node.vals, node.subtrees[1:]):
			res += f"  {k!r} ({MSTNode.key_height(k)}) -> {v.encode("base32")},\n"
			res += indent(self.pretty(t)) + ",\n"
		res += ")"
		return res


if __name__ == "__main__":
	if 0:
		from carfile import ReadOnlyCARBlockStore
		f = open("/home/david/programming/python/bskyclient/retr0id.car", "rb")
		bs = ReadOnlyCARBlockStore(f)
		commit_obj = dag_cbor.decode(bs.get(bytes(bs.car_roots[0])))
		mst_root: CID = commit_obj["data"]
		ns = NodeStore(bs)
		mst = NodeWrangler(ns, mst_root)
		print(mst)
	else:
		bs = MemoryBlockStore()
		ns = NodeStore(bs)
		mst = NodeWrangler(ns)
		root = ns.get(None).cid
		print(mst.pretty(root))
		root = mst.put(root, "hello", hash_to_cid(b"blah"))
		print(mst.pretty(root))
		root = mst.put(root, "foo", hash_to_cid(b"bar"))
		print(mst.pretty(root))
		root = mst.put(root, "bar", hash_to_cid(b"bat"))
		print(mst.pretty(root))
		root = mst.delete(root, "foo")
		root = mst.delete(root, "hello")
		print(mst.pretty(root))
		root = mst.delete(root, "bar")
		print(mst.pretty(root))
		root = mst.delete(root, "bar")
		print(mst.pretty(root))
